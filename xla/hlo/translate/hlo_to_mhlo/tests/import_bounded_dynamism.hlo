// RUN: xla-translate -hlo-text-to-mlir-hlo -hlo-import-all-computations -split-input-file %s -o - | FileCheck %s


HloModule main, entry_computation_layout={(pred[<=1801,1]{1,0})->pred[<=1801,1]{1,0}}

ENTRY %convert_with_predicate (Arg_0.1: pred[<=1801,1]) -> pred[<=1801,1] {
  // CHECK:      [[CST:%.*]] = mhlo.constant dense<false> : tensor<1801x1xi1>
  // CHECK-NEXT: [[GDS:%.*]] = "mhlo.get_dimension_size"(%arg0) <{dimension = 0 : i64}> : (tensor<?x1xi1, #mhlo.type_extensions<bounds = [1801, ?]>>) -> tensor<i32>
  // CHECK-NEXT: [[SDS:%.*]] = "mhlo.set_dimension_size"([[CST]], [[GDS]]) <{dimension = 0 : i64}> : (tensor<1801x1xi1>, tensor<i32>) -> tensor<?x1xi1, #mhlo.type_extensions<bounds = [1801, ?]>>
  // CHECK-NEXT: [[CMP:%.*]] = mhlo.compare  NE, %arg0, [[SDS]] : (tensor<?x1xi1, #mhlo.type_extensions<bounds = [1801, ?]>>, tensor<?x1xi1, #mhlo.type_extensions<bounds = [1801, ?]>>) -> tensor<?x1xi1, #mhlo.type_extensions<bounds = [1801, ?]>>
  // CHECK-NEXT: return [[CMP]] : tensor<?x1xi1, #mhlo.type_extensions<bounds = [1801, ?]>>
  %Arg_0.1 = pred[<=1801,1] parameter(0)
  ROOT %convert_pred = pred[<=1801,1] convert(%Arg_0.1)
}

// -----

HloModule main, entry_computation_layout={(f32[<=1801,1]{1,0})->f32[<=1801,1]{1,0}}

ENTRY %convert_with_f32icate (Arg_0.1: f32[<=1801,1]) -> f32[<=1801,1] {
  // CHECK:       [[CVT:%.*]] = mhlo.convert %arg0 : tensor<?x1xf32, #mhlo.type_extensions<bounds = [1801, ?]>>
  // CHECK-NEXT:  return [[CVT]] : tensor<?x1xf32, #mhlo.type_extensions<bounds = [1801, ?]>>
  %Arg_0.1 = f32[<=1801,1] parameter(0)
  ROOT %convert_f32 = f32[<=1801,1] convert(%Arg_0.1)
}

